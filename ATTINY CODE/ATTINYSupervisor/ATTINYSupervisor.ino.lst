
C:\Users\jwiebe\AppData\Local\Temp\arduino_build_689290/ATTINYSupervisor.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	2b c0       	rjmp	.+86     	; 0x58 <__ctors_end>
   2:	45 c0       	rjmp	.+138    	; 0x8e <__bad_interrupt>
   4:	cd c2       	rjmp	.+1434   	; 0x5a0 <__vector_2>
   6:	43 c0       	rjmp	.+134    	; 0x8e <__bad_interrupt>
   8:	d5 c2       	rjmp	.+1450   	; 0x5b4 <__vector_4>
   a:	41 c0       	rjmp	.+130    	; 0x8e <__bad_interrupt>
   c:	40 c0       	rjmp	.+128    	; 0x8e <__bad_interrupt>
   e:	3f c0       	rjmp	.+126    	; 0x8e <__bad_interrupt>
  10:	3e c0       	rjmp	.+124    	; 0x8e <__bad_interrupt>
  12:	3d c0       	rjmp	.+122    	; 0x8e <__bad_interrupt>
  14:	3c c0       	rjmp	.+120    	; 0x8e <__bad_interrupt>
  16:	7c c1       	rjmp	.+760    	; 0x310 <__vector_11>
  18:	3a c0       	rjmp	.+116    	; 0x8e <__bad_interrupt>
  1a:	39 c0       	rjmp	.+114    	; 0x8e <__bad_interrupt>
  1c:	38 c0       	rjmp	.+112    	; 0x8e <__bad_interrupt>
  1e:	79 c2       	rjmp	.+1266   	; 0x512 <__vector_15>
  20:	c1 c1       	rjmp	.+898    	; 0x3a4 <__vector_16>

00000022 <__trampolines_end>:
__trampolines_start():
  22:	00 00       	nop
  24:	39 00       	.word	0x0039	; ????
  26:	36 00       	.word	0x0036	; ????

00000028 <digital_pin_to_timer_PGM>:
  28:	00 00 00 00 00 04 03 02 01 00 00 00                 ............

00000034 <port_to_output_PGM>:
  34:	00 00 3b 00 38 00                                   ..;.8.

0000003a <port_to_mode_PGM>:
  3a:	00 00 3a 00 37 00                                   ..:.7.

00000040 <digital_pin_to_port_PGM>:
  40:	01 01 01 01 01 01 01 01 02 02 02 02                 ............

0000004c <digital_pin_to_bit_mask_PGM>:
  4c:	01 02 04 08 10 20 40 80 04 02 01 08                 ..... @.....

00000058 <__ctors_end>:
__dtors_end():
  58:	11 24       	eor	r1, r1
  5a:	1f be       	out	0x3f, r1	; 63
  5c:	cf e5       	ldi	r28, 0x5F	; 95
  5e:	d2 e0       	ldi	r29, 0x02	; 2
  60:	de bf       	out	0x3e, r29	; 62
  62:	cd bf       	out	0x3d, r28	; 61

00000064 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  64:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  66:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  68:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  6a:	ee e6       	ldi	r30, 0x6E	; 110
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  6c:	f7 e0       	ldi	r31, 0x07	; 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  6e:	02 c0       	rjmp	.+4      	; 0x74 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  70:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  72:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  74:	a8 36       	cpi	r26, 0x68	; 104
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  76:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  78:	d9 f7       	brne	.-10     	; 0x70 <__do_copy_data+0xc>

0000007a <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  7a:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  7c:	a8 e6       	ldi	r26, 0x68	; 104
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  7e:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  80:	01 c0       	rjmp	.+2      	; 0x84 <.do_clear_bss_start>

00000082 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  82:	1d 92       	st	X+, r1

00000084 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  84:	af 39       	cpi	r26, 0x9F	; 159
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  86:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  88:	e1 f7       	brne	.-8      	; 0x82 <.do_clear_bss_loop>
.do_clear_bss_start():
  8a:	b9 d2       	rcall	.+1394   	; 0x5fe <main>
  8c:	6e c3       	rjmp	.+1756   	; 0x76a <_exit>

0000008e <__bad_interrupt>:
__vector_1():
  8e:	b8 cf       	rjmp	.-144    	; 0x0 <__vectors>

00000090 <TwoWire::read() [clone .constprop.6]>:
_ZN7TwoWire4readEv.constprop.6():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:542

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
  90:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <TwoWire::BufferLength>
  94:	88 23       	and	r24, r24
  96:	39 f0       	breq	.+14     	; 0xa6 <TwoWire::read() [clone .constprop.6]+0x16>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:543
    return BufferLength - BufferIndex;
  98:	20 91 9d 00 	lds	r18, 0x009D	; 0x80009d <TwoWire::BufferIndex>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:556
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
  9c:	82 13       	cpse	r24, r18
  9e:	1c c0       	rjmp	.+56     	; 0xd8 <TwoWire::read() [clone .constprop.6]+0x48>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:553

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
  a0:	8f ef       	ldi	r24, 0xFF	; 255
  a2:	9f ef       	ldi	r25, 0xFF	; 255
  a4:	08 95       	ret
USI_TWI_Data_In_Receive_Buffer():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
  a6:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
  aa:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <TWI_RxHead>
  ae:	89 1b       	sub	r24, r25
  b0:	8f 70       	andi	r24, 0x0F	; 15
_ZN7TwoWire4readEv.constprop.6():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:556

  // get each successive byte on each call
  if (available()) {
  b2:	b1 f3       	breq	.-20     	; 0xa0 <TwoWire::read() [clone .constprop.6]+0x10>
USI_TWI_Receive_Byte():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
  b4:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
  b8:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <TWI_RxHead>
  bc:	98 17       	cp	r25, r24
  be:	e1 f3       	breq	.-8      	; 0xb8 <TwoWire::read() [clone .constprop.6]+0x28>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
  c0:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <TWI_RxTail>
  c4:	ef 5f       	subi	r30, 0xFF	; 255
  c6:	ef 70       	andi	r30, 0x0F	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
  c8:	e0 93 9c 00 	sts	0x009C, r30	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	e8 59       	subi	r30, 0x98	; 152
  d0:	ff 4f       	sbci	r31, 0xFF	; 255
_ZN7TwoWire4readEv.constprop.6():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:561
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
  d2:	80 81       	ld	r24, Z
  d4:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:566
    }
  }

  return value;
}
  d6:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:558
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
  d8:	e2 2f       	mov	r30, r18
  da:	f0 e0       	ldi	r31, 0x00	; 0
  dc:	e8 59       	subi	r30, 0x98	; 152
  de:	ff 4f       	sbci	r31, 0xFF	; 255
  e0:	80 81       	ld	r24, Z
  e2:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:559
      ++BufferIndex;
  e4:	2f 5f       	subi	r18, 0xFF	; 255
  e6:	20 93 9d 00 	sts	0x009D, r18	; 0x80009d <TwoWire::BufferIndex>
  ea:	08 95       	ret

000000ec <TwoWire::write(unsigned char) [clone .constprop.5]>:
_ZN7TwoWire5writeEh.constprop.5():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  ec:	20 91 9a 00 	lds	r18, 0x009A	; 0x80009a <TWI_TxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  f0:	90 91 99 00 	lds	r25, 0x0099	; 0x800099 <TWI_TxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
  f4:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
  f6:	92 1b       	sub	r25, r18
  f8:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:510
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
  fa:	91 f0       	breq	.+36     	; 0x120 <TwoWire::write(unsigned char) [clone .constprop.5]+0x34>
USI_TWI_Transmit_Byte():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
  fc:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <TWI_TxHead>
 100:	9f 5f       	subi	r25, 0xFF	; 255
 102:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
 104:	20 91 99 00 	lds	r18, 0x0099	; 0x800099 <TWI_TxTail>
 108:	92 17       	cp	r25, r18
 10a:	e1 f3       	breq	.-8      	; 0x104 <TwoWire::write(unsigned char) [clone .constprop.5]+0x18>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 10c:	e9 2f       	mov	r30, r25
 10e:	f0 e0       	ldi	r31, 0x00	; 0
 110:	e8 58       	subi	r30, 0x88	; 136
 112:	ff 4f       	sbci	r31, 0xFF	; 255
 114:	80 83       	st	Z, r24
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 116:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <TWI_TxHead>
_ZN7TwoWire5writeEh.constprop.5():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:516
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
 11a:	81 e0       	ldi	r24, 0x01	; 1
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:511
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
      return 0;
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:517
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
}
 124:	08 95       	ret

00000126 <turnOffPWM>:
turnOffPWM():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:67
}

static void turnOffPWM(uint8_t timer)
{
  #if defined(TCCR0A) && defined(COM0A1)
  if( timer == TIMER0A){
 126:	81 30       	cpi	r24, 0x01	; 1
 128:	21 f4       	brne	.+8      	; 0x132 <turnOffPWM+0xc>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:68
    cbi(TCCR0A, COM0A1);
 12a:	80 b7       	in	r24, 0x30	; 48
 12c:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:75
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
    cbi(TCCR0A, COM0B1);
 12e:	80 bf       	out	0x30, r24	; 48
 130:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:74
    //cbi(TCCR0A, COM0A0);
  } else
  #endif

  #if defined(TCCR0A) && defined(COM0B1)
  if( timer == TIMER0B){
 132:	82 30       	cpi	r24, 0x02	; 2
 134:	19 f4       	brne	.+6      	; 0x13c <turnOffPWM+0x16>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:75
    cbi(TCCR0A, COM0B1);
 136:	80 b7       	in	r24, 0x30	; 48
 138:	8f 7d       	andi	r24, 0xDF	; 223
 13a:	f9 cf       	rjmp	.-14     	; 0x12e <turnOffPWM+0x8>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:81
    //cbi(TCCR0A, COM0B0);
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1A1)
  if( timer == TIMER1A){
 13c:	83 30       	cpi	r24, 0x03	; 3
 13e:	21 f4       	brne	.+8      	; 0x148 <turnOffPWM+0x22>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:82
    cbi(TCCR1A, COM1A1);
 140:	8f b5       	in	r24, 0x2f	; 47
 142:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:116
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
    cbi(TCCR1A, COM1B1);
 144:	8f bd       	out	0x2f, r24	; 47
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:134
  #endif

    {
    }

}
 146:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:115
  #endif
  } else
  #endif

  #if defined(TCCR1A) && defined(COM1B1)
  if( timer == TIMER1B){
 148:	84 30       	cpi	r24, 0x04	; 4
 14a:	e9 f7       	brne	.-6      	; 0x146 <turnOffPWM+0x20>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:116
    cbi(TCCR1A, COM1B1);
 14c:	8f b5       	in	r24, 0x2f	; 47
 14e:	8f 7d       	andi	r24, 0xDF	; 223
 150:	f9 cf       	rjmp	.-14     	; 0x144 <turnOffPWM+0x1e>

00000152 <digitalRead>:
digitalRead():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:166
    SREG = oldSREG;
  }
}

int digitalRead(uint8_t pin)
{
 152:	cf 93       	push	r28
 154:	df 93       	push	r29
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:167
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 156:	87 fd       	sbrc	r24, 7
 158:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:168
  uint8_t timer = digitalPinToTimer(pin);
 15a:	28 2f       	mov	r18, r24
 15c:	30 e0       	ldi	r19, 0x00	; 0
 15e:	f9 01       	movw	r30, r18
 160:	e8 5d       	subi	r30, 0xD8	; 216
 162:	ff 4f       	sbci	r31, 0xFF	; 255
 164:	84 91       	lpm	r24, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:169
  uint8_t bit = digitalPinToBitMask(pin);
 166:	f9 01       	movw	r30, r18
 168:	e4 5b       	subi	r30, 0xB4	; 180
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	d4 91       	lpm	r29, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:170
  uint8_t port = digitalPinToPort(pin);
 16e:	f9 01       	movw	r30, r18
 170:	e0 5c       	subi	r30, 0xC0	; 192
 172:	ff 4f       	sbci	r31, 0xFF	; 255
 174:	c4 91       	lpm	r28, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:172

  if (port == NOT_A_PIN) return LOW;
 176:	cc 23       	and	r28, r28
 178:	99 f0       	breq	.+38     	; 0x1a0 <digitalRead+0x4e>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:176

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 17a:	81 11       	cpse	r24, r1
 17c:	d4 df       	rcall	.-88     	; 0x126 <turnOffPWM>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:178

  if (*portInputRegister(port) & bit) return HIGH;
 17e:	ec 2f       	mov	r30, r28
 180:	f0 e0       	ldi	r31, 0x00	; 0
 182:	ee 0f       	add	r30, r30
 184:	ff 1f       	adc	r31, r31
 186:	ee 5d       	subi	r30, 0xDE	; 222
 188:	ff 4f       	sbci	r31, 0xFF	; 255
 18a:	a5 91       	lpm	r26, Z+
 18c:	b4 91       	lpm	r27, Z
 18e:	ec 91       	ld	r30, X
 190:	ed 23       	and	r30, r29
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	09 f4       	brne	.+2      	; 0x19a <digitalRead+0x48>
 198:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:180
  return LOW;
}
 19a:	df 91       	pop	r29
 19c:	cf 91       	pop	r28
 19e:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:172
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if (port == NOT_A_PIN) return LOW;
 1a0:	80 e0       	ldi	r24, 0x00	; 0
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	fa cf       	rjmp	.-12     	; 0x19a <digitalRead+0x48>

000001a6 <digitalWrite>:
digitalWrite():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:137
    }

}

void digitalWrite(uint8_t pin, uint8_t val)
{
 1a6:	1f 93       	push	r17
 1a8:	cf 93       	push	r28
 1aa:	df 93       	push	r29
 1ac:	16 2f       	mov	r17, r22
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:138
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
 1ae:	87 fd       	sbrc	r24, 7
 1b0:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:139
  uint8_t timer = digitalPinToTimer(pin);
 1b2:	28 2f       	mov	r18, r24
 1b4:	30 e0       	ldi	r19, 0x00	; 0
 1b6:	f9 01       	movw	r30, r18
 1b8:	e8 5d       	subi	r30, 0xD8	; 216
 1ba:	ff 4f       	sbci	r31, 0xFF	; 255
 1bc:	84 91       	lpm	r24, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:140
  uint8_t bit = digitalPinToBitMask(pin);
 1be:	f9 01       	movw	r30, r18
 1c0:	e4 5b       	subi	r30, 0xB4	; 180
 1c2:	ff 4f       	sbci	r31, 0xFF	; 255
 1c4:	d4 91       	lpm	r29, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:141
  uint8_t port = digitalPinToPort(pin);
 1c6:	f9 01       	movw	r30, r18
 1c8:	e0 5c       	subi	r30, 0xC0	; 192
 1ca:	ff 4f       	sbci	r31, 0xFF	; 255
 1cc:	c4 91       	lpm	r28, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:144
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 1ce:	cc 23       	and	r28, r28
 1d0:	99 f0       	breq	.+38     	; 0x1f8 <digitalWrite+0x52>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:148

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 1d2:	81 11       	cpse	r24, r1
 1d4:	a8 df       	rcall	.-176    	; 0x126 <turnOffPWM>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:150

  out = portOutputRegister(port);
 1d6:	ec 2f       	mov	r30, r28
 1d8:	f0 e0       	ldi	r31, 0x00	; 0
 1da:	ee 0f       	add	r30, r30
 1dc:	ff 1f       	adc	r31, r31
 1de:	ec 5c       	subi	r30, 0xCC	; 204
 1e0:	ff 4f       	sbci	r31, 0xFF	; 255
 1e2:	a5 91       	lpm	r26, Z+
 1e4:	b4 91       	lpm	r27, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:153

  if (val == LOW) {
    uint8_t oldSREG = SREG;
 1e6:	8f b7       	in	r24, 0x3f	; 63
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 1e8:	11 11       	cpse	r17, r1
 1ea:	0a c0       	rjmp	.+20     	; 0x200 <digitalWrite+0x5a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:154
    uint8_t oldSREG = SREG;
    cli();
 1ec:	f8 94       	cli
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 1ee:	ec 91       	ld	r30, X
 1f0:	d0 95       	com	r29
 1f2:	de 23       	and	r29, r30
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:160
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
 1f4:	dc 93       	st	X, r29
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
 1f6:	8f bf       	out	0x3f, r24	; 63
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:163
  }
}
 1f8:	df 91       	pop	r29
 1fa:	cf 91       	pop	r28
 1fc:	1f 91       	pop	r17
 1fe:	08 95       	ret
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:159
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 200:	f8 94       	cli
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 202:	ec 91       	ld	r30, X
 204:	de 2b       	or	r29, r30
 206:	f6 cf       	rjmp	.-20     	; 0x1f4 <digitalWrite+0x4e>

00000208 <receiveEvent(int)>:
_Z12receiveEventi():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:149
      break;
  }
  opcode = 0;
}

void receiveEvent(int bytesReceived) {
 208:	cf 92       	push	r12
 20a:	df 92       	push	r13
 20c:	ef 92       	push	r14
 20e:	ff 92       	push	r15
 210:	1f 93       	push	r17
 212:	cf 93       	push	r28
 214:	df 93       	push	r29
 216:	00 d0       	rcall	.+0      	; 0x218 <receiveEvent(int)+0x10>
 218:	00 d0       	rcall	.+0      	; 0x21a <receiveEvent(int)+0x12>
 21a:	cd b7       	in	r28, 0x3d	; 61
 21c:	de b7       	in	r29, 0x3e	; 62
 21e:	7c 01       	movw	r14, r24
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:151
  // Read the first byte to determine which register is concerned
  opcode = Wire.read();
 220:	37 df       	rcall	.-402    	; 0x90 <TwoWire::read() [clone .constprop.6]>
 222:	18 2f       	mov	r17, r24
 224:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <opcode>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:153
  // If there are more than 1 byte, then the master is writing to the slave
  if (bytesReceived > 1) {
 228:	82 e0       	ldi	r24, 0x02	; 2
 22a:	e8 16       	cp	r14, r24
 22c:	f1 04       	cpc	r15, r1
 22e:	e4 f0       	brlt	.+56     	; 0x268 <__stack+0x9>
 230:	fe 01       	movw	r30, r28
 232:	31 96       	adiw	r30, 0x01	; 1
 234:	7f 01       	movw	r14, r30
 236:	6e 01       	movw	r12, r28
 238:	f5 e0       	ldi	r31, 0x05	; 5
 23a:	cf 0e       	add	r12, r31
 23c:	d1 1c       	adc	r13, r1
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:156
    fourByteArray converter; //Create a converter
    for (int i = 0; i < 4 ; i++) {
      converter.array[i] = Wire.read();
 23e:	28 df       	rcall	.-432    	; 0x90 <TwoWire::read() [clone .constprop.6]>
 240:	f7 01       	movw	r30, r14
 242:	81 93       	st	Z+, r24
 244:	7f 01       	movw	r14, r30
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:155
  // Read the first byte to determine which register is concerned
  opcode = Wire.read();
  // If there are more than 1 byte, then the master is writing to the slave
  if (bytesReceived > 1) {
    fourByteArray converter; //Create a converter
    for (int i = 0; i < 4 ; i++) {
 246:	ec 15       	cp	r30, r12
 248:	fd 05       	cpc	r31, r13
 24a:	c9 f7       	brne	.-14     	; 0x23e <receiveEvent(int)+0x36>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:158
      converter.array[i] = Wire.read();
    }
    if (opcode == unixTimeRegister) {
 24c:	11 30       	cpi	r17, 0x01	; 1
 24e:	c1 f4       	brne	.+48     	; 0x280 <__stack+0x21>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:159
      UNIXTime = converter.integer;
 250:	89 81       	ldd	r24, Y+1	; 0x01
 252:	9a 81       	ldd	r25, Y+2	; 0x02
 254:	ab 81       	ldd	r26, Y+3	; 0x03
 256:	bc 81       	ldd	r27, Y+4	; 0x04
 258:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <UNIXTime>
 25c:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <UNIXTime+0x1>
 260:	a0 93 66 00 	sts	0x0066, r26	; 0x800066 <UNIXTime+0x2>
 264:	b0 93 67 00 	sts	0x0067, r27	; 0x800067 <UNIXTime+0x3>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:164
    } else if (opcode == WakeTimeRegister) {
      WakeTime = converter.integer;
    }
  }
}
 268:	0f 90       	pop	r0
 26a:	0f 90       	pop	r0
 26c:	0f 90       	pop	r0
 26e:	0f 90       	pop	r0
 270:	df 91       	pop	r29
 272:	cf 91       	pop	r28
 274:	1f 91       	pop	r17
 276:	ff 90       	pop	r15
 278:	ef 90       	pop	r14
 27a:	df 90       	pop	r13
 27c:	cf 90       	pop	r12
 27e:	08 95       	ret
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:160
    for (int i = 0; i < 4 ; i++) {
      converter.array[i] = Wire.read();
    }
    if (opcode == unixTimeRegister) {
      UNIXTime = converter.integer;
    } else if (opcode == WakeTimeRegister) {
 280:	12 30       	cpi	r17, 0x02	; 2
 282:	91 f7       	brne	.-28     	; 0x268 <__stack+0x9>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:161
      WakeTime = converter.integer;
 284:	89 81       	ldd	r24, Y+1	; 0x01
 286:	9a 81       	ldd	r25, Y+2	; 0x02
 288:	ab 81       	ldd	r26, Y+3	; 0x03
 28a:	bc 81       	ldd	r27, Y+4	; 0x04
 28c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 290:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 294:	a0 93 62 00 	sts	0x0062, r26	; 0x800062 <__data_start+0x2>
 298:	b0 93 63 00 	sts	0x0063, r27	; 0x800063 <__data_start+0x3>
 29c:	e5 cf       	rjmp	.-54     	; 0x268 <__stack+0x9>

0000029e <requestEvent()>:
_Z12requestEventv():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:115
    digitalWrite(BoronENpin, HIGH);
    boronControlState = 1;
  }
}

void requestEvent() {
 29e:	1f 93       	push	r17
 2a0:	cf 93       	push	r28
 2a2:	df 93       	push	r29
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:117
  fourByteArray converter;
  switch (opcode) {
 2a4:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <opcode>
 2a8:	82 30       	cpi	r24, 0x02	; 2
 2aa:	c9 f0       	breq	.+50     	; 0x2de <requestEvent()+0x40>
 2ac:	83 30       	cpi	r24, 0x03	; 3
 2ae:	01 f1       	breq	.+64     	; 0x2f0 <requestEvent()+0x52>
 2b0:	81 30       	cpi	r24, 0x01	; 1
 2b2:	31 f5       	brne	.+76     	; 0x300 <requestEvent()+0x62>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:119
    case unixTimeRegister:
      converter.integer = UNIXTime;
 2b4:	10 91 65 00 	lds	r17, 0x0065	; 0x800065 <UNIXTime+0x1>
 2b8:	d0 91 66 00 	lds	r29, 0x0066	; 0x800066 <UNIXTime+0x2>
 2bc:	c0 91 67 00 	lds	r28, 0x0067	; 0x800067 <UNIXTime+0x3>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:120
      Wire.write(converter.array[0]);
 2c0:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <UNIXTime>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:127
      Wire.write(converter.array[2]);
      Wire.write(converter.array[3]);
      break;
    case WakeTimeRegister:
      converter.integer = WakeTime;
      Wire.write(converter.array[0]);
 2c4:	13 df       	rcall	.-474    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:128
      Wire.write(converter.array[1]);
 2c6:	81 2f       	mov	r24, r17
 2c8:	11 df       	rcall	.-478    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:129
      Wire.write(converter.array[2]);
 2ca:	8d 2f       	mov	r24, r29
 2cc:	0f df       	rcall	.-482    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:130
      Wire.write(converter.array[3]);
 2ce:	8c 2f       	mov	r24, r28
write():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.h:138
    uint8_t isActive(void);

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
 2d0:	0d df       	rcall	.-486    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
_Z12requestEventv():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:146
    Wire.write(0x0);
    Wire.write(0x0);
    Wire.write(0x0);
      break;
  }
  opcode = 0;
 2d2:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <opcode>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:147
}
 2d6:	df 91       	pop	r29
 2d8:	cf 91       	pop	r28
 2da:	1f 91       	pop	r17
 2dc:	08 95       	ret
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:126
      Wire.write(converter.array[1]);
      Wire.write(converter.array[2]);
      Wire.write(converter.array[3]);
      break;
    case WakeTimeRegister:
      converter.integer = WakeTime;
 2de:	10 91 61 00 	lds	r17, 0x0061	; 0x800061 <__data_start+0x1>
 2e2:	d0 91 62 00 	lds	r29, 0x0062	; 0x800062 <__data_start+0x2>
 2e6:	c0 91 63 00 	lds	r28, 0x0063	; 0x800063 <__data_start+0x3>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:127
      Wire.write(converter.array[0]);
 2ea:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 2ee:	ea cf       	rjmp	.-44     	; 0x2c4 <requestEvent()+0x26>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:134
      Wire.write(converter.array[2]);
      Wire.write(converter.array[3]);
      break;
    case myIDRegister:
      converter.integer = myID;
      Wire.write(converter.array[0]);
 2f0:	8f e2       	ldi	r24, 0x2F	; 47
 2f2:	fc de       	rcall	.-520    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:135
      Wire.write(converter.array[1]);
 2f4:	82 e2       	ldi	r24, 0x22	; 34
 2f6:	fa de       	rcall	.-524    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:136
      Wire.write(converter.array[2]);
 2f8:	82 e2       	ldi	r24, 0x22	; 34
 2fa:	f8 de       	rcall	.-528    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:137
      Wire.write(converter.array[3]);
 2fc:	82 ef       	ldi	r24, 0xF2	; 242
 2fe:	e8 cf       	rjmp	.-48     	; 0x2d0 <requestEvent()+0x32>
write():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.h:138
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	f4 de       	rcall	.-536    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	f2 de       	rcall	.-540    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	f0 de       	rcall	.-544    	; 0xec <TwoWire::write(unsigned char) [clone .constprop.5]>
 30c:	80 e0       	ldi	r24, 0x00	; 0
 30e:	e0 cf       	rjmp	.-64     	; 0x2d0 <requestEvent()+0x32>

00000310 <__vector_11>:
__vector_11():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:130
#else

#error Millis() timer not defined!

#endif
{
 310:	1f 92       	push	r1
 312:	0f 92       	push	r0
 314:	0f b6       	in	r0, 0x3f	; 63
 316:	0f 92       	push	r0
 318:	11 24       	eor	r1, r1
 31a:	2f 93       	push	r18
 31c:	3f 93       	push	r19
 31e:	8f 93       	push	r24
 320:	9f 93       	push	r25
 322:	af 93       	push	r26
 324:	bf 93       	push	r27
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:133
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 326:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <millis_timer_millis>
 32a:	90 91 96 00 	lds	r25, 0x0096	; 0x800096 <millis_timer_millis+0x1>
 32e:	a0 91 97 00 	lds	r26, 0x0097	; 0x800097 <millis_timer_millis+0x2>
 332:	b0 91 98 00 	lds	r27, 0x0098	; 0x800098 <millis_timer_millis+0x3>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:134
  unsigned char f = millis_timer_fract;
 336:	30 91 94 00 	lds	r19, 0x0094	; 0x800094 <millis_timer_fract>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:146
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 33a:	26 e0       	ldi	r18, 0x06	; 6
 33c:	23 0f       	add	r18, r19
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:148

  if (f >= FRACT_MAX)
 33e:	2d 37       	cpi	r18, 0x7D	; 125
 340:	68 f1       	brcs	.+90     	; 0x39c <__vector_11+0x8c>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:150
  {
    f -= FRACT_MAX;
 342:	29 e8       	ldi	r18, 0x89	; 137
 344:	23 0f       	add	r18, r19
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:152
  m += 1;
    m += MILLIS_INC;
 346:	03 96       	adiw	r24, 0x03	; 3
 348:	a1 1d       	adc	r26, r1
 34a:	b1 1d       	adc	r27, r1
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:159
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 34c:	20 93 94 00 	sts	0x0094, r18	; 0x800094 <millis_timer_fract>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:160
  millis_timer_millis = m;
 350:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <millis_timer_millis>
 354:	90 93 96 00 	sts	0x0096, r25	; 0x800096 <millis_timer_millis+0x1>
 358:	a0 93 97 00 	sts	0x0097, r26	; 0x800097 <millis_timer_millis+0x2>
 35c:	b0 93 98 00 	sts	0x0098, r27	; 0x800098 <millis_timer_millis+0x3>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:161
  millis_timer_overflow_count++;
 360:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <millis_timer_overflow_count>
 364:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <millis_timer_overflow_count+0x1>
 368:	a0 91 92 00 	lds	r26, 0x0092	; 0x800092 <millis_timer_overflow_count+0x2>
 36c:	b0 91 93 00 	lds	r27, 0x0093	; 0x800093 <millis_timer_overflow_count+0x3>
 370:	01 96       	adiw	r24, 0x01	; 1
 372:	a1 1d       	adc	r26, r1
 374:	b1 1d       	adc	r27, r1
 376:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <millis_timer_overflow_count>
 37a:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <millis_timer_overflow_count+0x1>
 37e:	a0 93 92 00 	sts	0x0092, r26	; 0x800092 <millis_timer_overflow_count+0x2>
 382:	b0 93 93 00 	sts	0x0093, r27	; 0x800093 <millis_timer_overflow_count+0x3>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:168

//MICROSECONDS_PER_MILLIS_OVERFLOW=2048
//MILLIS_INC=2
//FRACT_INC=6
//FRACT_MAX=125
}
 386:	bf 91       	pop	r27
 388:	af 91       	pop	r26
 38a:	9f 91       	pop	r25
 38c:	8f 91       	pop	r24
 38e:	3f 91       	pop	r19
 390:	2f 91       	pop	r18
 392:	0f 90       	pop	r0
 394:	0f be       	out	0x3f, r0	; 63
 396:	0f 90       	pop	r0
 398:	1f 90       	pop	r1
 39a:	18 95       	reti
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:156
  m += 1;
    m += MILLIS_INC;
  }
  else
  {
    m += MILLIS_INC;
 39c:	02 96       	adiw	r24, 0x02	; 2
 39e:	a1 1d       	adc	r26, r1
 3a0:	b1 1d       	adc	r27, r1
 3a2:	d4 cf       	rjmp	.-88     	; 0x34c <__vector_11+0x3c>

000003a4 <__vector_16>:
__vector_16():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
ISR(USI_OVERFLOW_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_OVERFLOW_VECTOR
__interrupt void USI_Counter_Overflow_ISR(void)
#endif
{
 3a4:	1f 92       	push	r1
 3a6:	0f 92       	push	r0
 3a8:	0f b6       	in	r0, 0x3f	; 63
 3aa:	0f 92       	push	r0
 3ac:	11 24       	eor	r1, r1
 3ae:	2f 93       	push	r18
 3b0:	3f 93       	push	r19
 3b2:	4f 93       	push	r20
 3b4:	5f 93       	push	r21
 3b6:	6f 93       	push	r22
 3b8:	7f 93       	push	r23
 3ba:	8f 93       	push	r24
 3bc:	9f 93       	push	r25
 3be:	af 93       	push	r26
 3c0:	bf 93       	push	r27
 3c2:	cf 93       	push	r28
 3c4:	ef 93       	push	r30
 3c6:	ff 93       	push	r31
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 3c8:	80 91 89 00 	lds	r24, 0x0089	; 0x800089 <USI_TWI_Overflow_State>
 3cc:	82 30       	cpi	r24, 0x02	; 2
 3ce:	09 f4       	brne	.+2      	; 0x3d2 <__vector_16+0x2e>
 3d0:	74 c0       	rjmp	.+232    	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
 3d2:	b8 f4       	brcc	.+46     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
 3d4:	88 23       	and	r24, r24
 3d6:	89 f1       	breq	.+98     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
 3d8:	81 30       	cpi	r24, 0x01	; 1
 3da:	09 f4       	brne	.+2      	; 0x3de <__vector_16+0x3a>
 3dc:	54 c0       	rjmp	.+168    	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:310
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 3de:	ff 91       	pop	r31
 3e0:	ef 91       	pop	r30
 3e2:	cf 91       	pop	r28
 3e4:	bf 91       	pop	r27
 3e6:	af 91       	pop	r26
 3e8:	9f 91       	pop	r25
 3ea:	8f 91       	pop	r24
 3ec:	7f 91       	pop	r23
 3ee:	6f 91       	pop	r22
 3f0:	5f 91       	pop	r21
 3f2:	4f 91       	pop	r20
 3f4:	3f 91       	pop	r19
 3f6:	2f 91       	pop	r18
 3f8:	0f 90       	pop	r0
 3fa:	0f be       	out	0x3f, r0	; 63
 3fc:	0f 90       	pop	r0
 3fe:	1f 90       	pop	r1
 400:	18 95       	reti
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 402:	84 30       	cpi	r24, 0x04	; 4
 404:	09 f4       	brne	.+2      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 406:	5f c0       	rjmp	.+190    	; 0x4c6 <__LOCK_REGION_LENGTH__+0xc6>
 408:	b8 f1       	brcs	.+110    	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
 40a:	85 30       	cpi	r24, 0x05	; 5
 40c:	41 f7       	brne	.-48     	; 0x3de <__vector_16+0x3a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 40e:	84 e0       	ldi	r24, 0x04	; 4
 410:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 414:	9f b1       	in	r25, 0x0f	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:299
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 416:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <TWI_RxHead>
 41a:	8f 5f       	subi	r24, 0xFF	; 255
 41c:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:300
    if (TWI_RxTail != tmpRxHead) {
 41e:	20 91 9c 00 	lds	r18, 0x009C	; 0x80009c <TWI_RxTail>
 422:	28 17       	cp	r18, r24
 424:	09 f4       	brne	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
 426:	73 c0       	rjmp	.+230    	; 0x50e <__LOCK_REGION_LENGTH__+0x10e>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:301
      TWI_RxHead            = tmpRxHead;
 428:	80 93 9b 00 	sts	0x009B, r24	; 0x80009b <TWI_RxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 42c:	e0 91 9b 00 	lds	r30, 0x009B	; 0x80009b <TWI_RxHead>
 430:	f0 e0       	ldi	r31, 0x00	; 0
 432:	e8 59       	subi	r30, 0x98	; 152
 434:	ff 4f       	sbci	r31, 0xFF	; 255
 436:	90 83       	st	Z, r25
 438:	19 c0       	rjmp	.+50     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:221

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 43a:	8f b1       	in	r24, 0x0f	; 15
 43c:	88 23       	and	r24, r24
 43e:	31 f0       	breq	.+12     	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
 440:	8f b1       	in	r24, 0x0f	; 15
 442:	86 95       	lsr	r24
 444:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <TWI_slaveAddress>
 448:	89 13       	cpse	r24, r25
 44a:	19 c0       	rjmp	.+50     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:222
      if (USIDR & 0x01) {
 44c:	78 9b       	sbis	0x0f, 0	; 15
 44e:	12 c0       	rjmp	.+36     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:223
        if (USI_TWI_On_Slave_Transmit) {
 450:	e0 91 8d 00 	lds	r30, 0x008D	; 0x80008d <USI_TWI_On_Slave_Transmit>
 454:	f0 91 8e 00 	lds	r31, 0x008E	; 0x80008e <USI_TWI_On_Slave_Transmit+0x1>
 458:	30 97       	sbiw	r30, 0x00	; 0
 45a:	29 f0       	breq	.+10     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:225
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
 45c:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <TWI_TxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
 460:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <TWI_TxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:227
          USI_TWI_On_Slave_Transmit();
 464:	09 95       	icall
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:229
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 466:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 468:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:233
      }
      SET_USI_TO_SEND_ACK();
 46c:	1f b8       	out	0x0f, r1	; 15
 46e:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 470:	8e e7       	ldi	r24, 0x7E	; 126
 472:	21 c0       	rjmp	.+66     	; 0x4b6 <__LOCK_REGION_LENGTH__+0xb6>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 474:	84 e0       	ldi	r24, 0x04	; 4
 476:	f8 cf       	rjmp	.-16     	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:242
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 478:	8f b1       	in	r24, 0x0f	; 15
 47a:	88 23       	and	r24, r24
 47c:	21 f0       	breq	.+8      	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 47e:	d6 98       	cbi	0x1a, 6	; 26
 480:	88 ea       	ldi	r24, 0xA8	; 168
 482:	8d b9       	out	0x0d, r24	; 13
 484:	17 c0       	rjmp	.+46     	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:253

  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 486:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <TWI_TxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:254
    if (TWI_TxHead != tmpTxTail) {
 48a:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <TWI_TxHead>
 48e:	98 17       	cp	r25, r24
 490:	b1 f3       	breq	.-20     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 492:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <TWI_TxTail>
 496:	8f 5f       	subi	r24, 0xFF	; 255
 498:	8f 70       	andi	r24, 0x0F	; 15
 49a:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <TWI_TxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:256
      USIDR      = TWI_TxBuf[TWI_TxTail];
 49e:	e0 91 99 00 	lds	r30, 0x0099	; 0x800099 <TWI_TxTail>
 4a2:	f0 e0       	ldi	r31, 0x00	; 0
 4a4:	e8 58       	subi	r30, 0x88	; 136
 4a6:	ff 4f       	sbci	r31, 0xFF	; 255
 4a8:	80 81       	ld	r24, Z
 4aa:	8f b9       	out	0x0f, r24	; 15
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:262
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 4ac:	82 e0       	ldi	r24, 0x02	; 2
 4ae:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:263
    SET_USI_TO_SEND_DATA();
 4b2:	d6 9a       	sbi	0x1a, 6	; 26
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 4b4:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 4b6:	8e b9       	out	0x0e, r24	; 14
 4b8:	92 cf       	rjmp	.-220    	; 0x3de <__vector_16+0x3a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:268
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 4ba:	83 e0       	ldi	r24, 0x03	; 3
 4bc:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:269
    SET_USI_TO_READ_ACK();
 4c0:	d6 98       	cbi	0x1a, 6	; 26
 4c2:	1f b8       	out	0x0f, r1	; 15
 4c4:	d5 cf       	rjmp	.-86     	; 0x470 <__LOCK_REGION_LENGTH__+0x70>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:275
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 4c6:	85 e0       	ldi	r24, 0x05	; 5
 4c8:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:276
    SET_USI_TO_READ_DATA();
 4cc:	d6 98       	cbi	0x1a, 6	; 26
 4ce:	80 e7       	ldi	r24, 0x70	; 112
 4d0:	8e b9       	out	0x0e, r24	; 14
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:278
    // call slave receive callback on stop condition
    if (USI_TWI_On_Slave_Receive) {
 4d2:	e0 91 8b 00 	lds	r30, 0x008B	; 0x80008b <USI_TWI_On_Slave_Receive>
 4d6:	f0 91 8c 00 	lds	r31, 0x008C	; 0x80008c <USI_TWI_On_Slave_Receive+0x1>
 4da:	30 97       	sbiw	r30, 0x00	; 0
 4dc:	09 f4       	brne	.+2      	; 0x4e0 <__LOCK_REGION_LENGTH__+0xe0>
 4de:	7f cf       	rjmp	.-258    	; 0x3de <__vector_16+0x3a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:279
      tmpRxHead = TWI_RxHead;
 4e0:	c0 91 9b 00 	lds	r28, 0x009B	; 0x80009b <TWI_RxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:280
      if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 4e4:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <TWI_RxTail>
 4e8:	8c 17       	cp	r24, r28
 4ea:	09 f4       	brne	.+2      	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
 4ec:	78 cf       	rjmp	.-272    	; 0x3de <__vector_16+0x3a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:282
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
 4ee:	8e b1       	in	r24, 0x0e	; 14
 4f0:	8e 7a       	andi	r24, 0xAE	; 174
 4f2:	e9 f3       	breq	.-6      	; 0x4ee <__LOCK_REGION_LENGTH__+0xee>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:285
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
 4f4:	75 9b       	sbis	0x0e, 5	; 14
 4f6:	73 cf       	rjmp	.-282    	; 0x3de <__vector_16+0x3a>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 4f8:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 4fc:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <TWI_RxHead>
 500:	89 1b       	sub	r24, r25
 502:	8f 70       	andi	r24, 0x0F	; 15
__vector_16():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:286
        // check for stop Condition
        while ((USISR & ((1 << USI_START_COND_INT) | (1 << USIPF) | (0xE << USICNT0))) == 0)
          ;// wait for either Start or Stop Condition
          // cancel after one SCL cycle
        if (USISR & (1 << USIPF)) { // Stop Condition
          USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 504:	90 e0       	ldi	r25, 0x00	; 0
 506:	09 95       	icall
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:288
          // reset rx buffer
          TWI_RxTail = tmpRxHead;
 508:	c0 93 9c 00 	sts	0x009C, r28	; 0x80009c <TWI_RxTail>
 50c:	68 cf       	rjmp	.-304    	; 0x3de <__vector_16+0x3a>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 50e:	d6 98       	cbi	0x1a, 6	; 26
 510:	af cf       	rjmp	.-162    	; 0x470 <__LOCK_REGION_LENGTH__+0x70>

00000512 <__vector_15>:
__vector_15():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 512:	1f 92       	push	r1
 514:	0f 92       	push	r0
 516:	0f b6       	in	r0, 0x3f	; 63
 518:	0f 92       	push	r0
 51a:	11 24       	eor	r1, r1
 51c:	2f 93       	push	r18
 51e:	3f 93       	push	r19
 520:	4f 93       	push	r20
 522:	5f 93       	push	r21
 524:	6f 93       	push	r22
 526:	7f 93       	push	r23
 528:	8f 93       	push	r24
 52a:	9f 93       	push	r25
 52c:	af 93       	push	r26
 52e:	bf 93       	push	r27
 530:	cf 93       	push	r28
 532:	ef 93       	push	r30
 534:	ff 93       	push	r31
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:169
  unsigned char tmpPin; // Temporary variable for pin state
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
 536:	e0 91 8b 00 	lds	r30, 0x008B	; 0x80008b <USI_TWI_On_Slave_Receive>
 53a:	f0 91 8c 00 	lds	r31, 0x008C	; 0x80008c <USI_TWI_On_Slave_Receive+0x1>
 53e:	30 97       	sbiw	r30, 0x00	; 0
 540:	81 f0       	breq	.+32     	; 0x562 <__vector_15+0x50>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:170
    tmpRxHead = TWI_RxHead;
 542:	c0 91 9b 00 	lds	r28, 0x009B	; 0x80009b <TWI_RxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:171
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
 546:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <TWI_RxTail>
 54a:	8c 17       	cp	r24, r28
 54c:	51 f0       	breq	.+20     	; 0x562 <__vector_15+0x50>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 54e:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 552:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <TWI_RxHead>
 556:	89 1b       	sub	r24, r25
 558:	8f 70       	andi	r24, 0x0F	; 15
__vector_15():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:172
  unsigned char tmpRxHead; // Temporary variable to store volatile
  // call slave receive callback on repeated start
  if (USI_TWI_On_Slave_Receive) {
    tmpRxHead = TWI_RxHead;
    if (TWI_RxTail != tmpRxHead) { // data in receive buffer
      USI_TWI_On_Slave_Receive(USI_TWI_Data_In_Receive_Buffer());
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	09 95       	icall
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:174
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
 55e:	c0 93 9c 00 	sts	0x009C, r28	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 562:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <USI_TWI_Overflow_State>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 566:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 568:	cc 9b       	sbis	0x19, 4	; 25
 56a:	18 c0       	rjmp	.+48     	; 0x59c <__vector_15+0x8a>
 56c:	ce 9b       	sbis	0x19, 6	; 25
 56e:	fc cf       	rjmp	.-8      	; 0x568 <__vector_15+0x56>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 570:	88 ea       	ldi	r24, 0xA8	; 168
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 572:	8d b9       	out	0x0d, r24	; 13
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 574:	80 ef       	ldi	r24, 0xF0	; 240
 576:	8e b9       	out	0x0e, r24	; 14
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 578:	ff 91       	pop	r31
 57a:	ef 91       	pop	r30
 57c:	cf 91       	pop	r28
 57e:	bf 91       	pop	r27
 580:	af 91       	pop	r26
 582:	9f 91       	pop	r25
 584:	8f 91       	pop	r24
 586:	7f 91       	pop	r23
 588:	6f 91       	pop	r22
 58a:	5f 91       	pop	r21
 58c:	4f 91       	pop	r20
 58e:	3f 91       	pop	r19
 590:	2f 91       	pop	r18
 592:	0f 90       	pop	r0
 594:	0f be       	out	0x3f, r0	; 63
 596:	0f 90       	pop	r0
 598:	1f 90       	pop	r1
 59a:	18 95       	reti
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 59c:	88 ef       	ldi	r24, 0xF8	; 248
 59e:	e9 cf       	rjmp	.-46     	; 0x572 <__vector_15+0x60>

000005a0 <__vector_2>:
__vector_2():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:85
ISR(WDT_vect) {
  //Wake up
  UNIXTime++;//increament unix timer
}

ISR(PCINT0_vect) {
 5a0:	1f 92       	push	r1
 5a2:	0f 92       	push	r0
 5a4:	0f b6       	in	r0, 0x3f	; 63
 5a6:	0f 92       	push	r0
 5a8:	11 24       	eor	r1, r1
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:87
  //wake on Pin Change
}
 5aa:	0f 90       	pop	r0
 5ac:	0f be       	out	0x3f, r0	; 63
 5ae:	0f 90       	pop	r0
 5b0:	1f 90       	pop	r1
 5b2:	18 95       	reti

000005b4 <__vector_4>:
__vector_4():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:80
  sleep_enable();
  set_sleep_mode(SLEEP_MODE_IDLE);
  sleep_cpu ();
}

ISR(WDT_vect) {
 5b4:	1f 92       	push	r1
 5b6:	0f 92       	push	r0
 5b8:	0f b6       	in	r0, 0x3f	; 63
 5ba:	0f 92       	push	r0
 5bc:	11 24       	eor	r1, r1
 5be:	8f 93       	push	r24
 5c0:	9f 93       	push	r25
 5c2:	af 93       	push	r26
 5c4:	bf 93       	push	r27
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:82
  //Wake up
  UNIXTime++;//increament unix timer
 5c6:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <UNIXTime>
 5ca:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <UNIXTime+0x1>
 5ce:	a0 91 66 00 	lds	r26, 0x0066	; 0x800066 <UNIXTime+0x2>
 5d2:	b0 91 67 00 	lds	r27, 0x0067	; 0x800067 <UNIXTime+0x3>
 5d6:	01 96       	adiw	r24, 0x01	; 1
 5d8:	a1 1d       	adc	r26, r1
 5da:	b1 1d       	adc	r27, r1
 5dc:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <UNIXTime>
 5e0:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <UNIXTime+0x1>
 5e4:	a0 93 66 00 	sts	0x0066, r26	; 0x800066 <UNIXTime+0x2>
 5e8:	b0 93 67 00 	sts	0x0067, r27	; 0x800067 <UNIXTime+0x3>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:83
}
 5ec:	bf 91       	pop	r27
 5ee:	af 91       	pop	r26
 5f0:	9f 91       	pop	r25
 5f2:	8f 91       	pop	r24
 5f4:	0f 90       	pop	r0
 5f6:	0f be       	out	0x3f, r0	; 63
 5f8:	0f 90       	pop	r0
 5fa:	1f 90       	pop	r1
 5fc:	18 95       	reti

000005fe <main>:
main():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/main.cpp:6
#include <Arduino.h>

int main(void)
{
  #ifdef TUNED_OSCCAL_VALUE
  OSCCAL = TUNED_OSCCAL_VALUE; //set the oscillator calibration value based on the pins_arduino.h file. If this is not set, it will be optimised away
 5fe:	81 b7       	in	r24, 0x31	; 49
 600:	81 bf       	out	0x31, r24	; 49
init():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:802
  #endif
  #endif

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0) && defined(WGM01)
  sbi(TCCR0A, WGM01);
 602:	80 b7       	in	r24, 0x30	; 48
 604:	82 60       	ori	r24, 0x02	; 2
 606:	80 bf       	out	0x30, r24	; 48
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:803
  sbi(TCCR0A, WGM00);
 608:	80 b7       	in	r24, 0x30	; 48
 60a:	81 60       	ori	r24, 0x01	; 1
 60c:	80 bf       	out	0x30, r24	; 48
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:826
  #endif

  // Millis timer is always processor clock divided by MillisTimer_Prescale_Value (64)
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
   #ifdef TCCR0B
    TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | (MillisTimer_Prescale_Index << CS00);
 60e:	83 b7       	in	r24, 0x33	; 51
 610:	88 7f       	andi	r24, 0xF8	; 248
 612:	83 60       	ori	r24, 0x03	; 3
 614:	83 bf       	out	0x33, r24	; 51
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:838
  TCCR1B = (TCCR1B & ~((1<<CS13)|(1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_MILLIS == 1)
  TCCR1B = (TCCR1B & ~((1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #endif
  // this needs to be called before setup() or some functions won't work there
  sei();
 616:	78 94       	sei
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:844

  // Enable the overlow interrupt (this is the basic system tic-toc for millis)
  #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK, TOIE0);
  #elif defined(TIMSK0) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK0, TOIE0);
 618:	89 b7       	in	r24, 0x39	; 57
 61a:	81 60       	ori	r24, 0x01	; 1
 61c:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:523
  sbi(TCCR1C, PWM1D);
  cbi(TCCR1D, WGM11);
  sbi(TCCR1D, WGM10);
  TCCR1B |= (ToneTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_TONE == 1)
  TCCR1B &= ~((1<<CS12) | (1<<CS11) | (1<<CS10)); //stop the clock to configure
 61e:	8e b5       	in	r24, 0x2e	; 46
 620:	88 7f       	andi	r24, 0xF8	; 248
 622:	8e bd       	out	0x2e, r24	; 46
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:525
  // Use the Tone Timer for phase correct PWM
  sbi(TCCR1A, WGM10);
 624:	8f b5       	in	r24, 0x2f	; 47
 626:	81 60       	ori	r24, 0x01	; 1
 628:	8f bd       	out	0x2f, r24	; 47
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:526
  cbi(TCCR1A, WGM11);
 62a:	8f b5       	in	r24, 0x2f	; 47
 62c:	8d 7f       	andi	r24, 0xFD	; 253
 62e:	8f bd       	out	0x2f, r24	; 47
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:527
  cbi(TCCR1B, WGM12);
 630:	8e b5       	in	r24, 0x2e	; 46
 632:	87 7f       	andi	r24, 0xF7	; 247
 634:	8e bd       	out	0x2e, r24	; 46
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:528
  cbi(TCCR1B, WGM13);
 636:	8e b5       	in	r24, 0x2e	; 46
 638:	8f 7e       	andi	r24, 0xEF	; 239
 63a:	8e bd       	out	0x2e, r24	; 46
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:529
  TCCR1B |= (ToneTimer_Prescale_Index << CS10); //set the clock
 63c:	8e b5       	in	r24, 0x2e	; 46
 63e:	83 60       	ori	r24, 0x03	; 3
 640:	8e bd       	out	0x2e, r24	; 46
init():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:862

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
  #if defined(ADCSRA)
    // set a2d prescale factor
  ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 642:	86 b1       	in	r24, 0x06	; 6
 644:	88 77       	andi	r24, 0x78	; 120
 646:	86 68       	ori	r24, 0x86	; 134
 648:	86 b9       	out	0x06, r24	; 6
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring.c:864
    // enable a2d conversions
    sbi(ADCSRA, ADEN);
 64a:	37 9a       	sbi	0x06, 7	; 6
setup():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:33
  byte array[4];
  uint32_t integer;
};

void setup() {
  ADCSRA = 0; //Disable ADC, saves ~300uA
 64c:	16 b8       	out	0x06, r1	; 6
pinMode():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:35
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 64e:	ed e4       	ldi	r30, 0x4D	; 77
 650:	f0 e0       	ldi	r31, 0x00	; 0
 652:	24 91       	lpm	r18, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:36
  uint8_t port = digitalPinToPort(pin);
 654:	e1 e4       	ldi	r30, 0x41	; 65
 656:	f0 e0       	ldi	r31, 0x00	; 0
 658:	84 91       	lpm	r24, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:39
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
 65a:	88 23       	and	r24, r24
 65c:	99 f0       	breq	.+38     	; 0x684 <main+0x86>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:41

  reg = portModeRegister(port);
 65e:	90 e0       	ldi	r25, 0x00	; 0
 660:	88 0f       	add	r24, r24
 662:	99 1f       	adc	r25, r25
 664:	fc 01       	movw	r30, r24
 666:	e6 5c       	subi	r30, 0xC6	; 198
 668:	ff 4f       	sbci	r31, 0xFF	; 255
 66a:	a5 91       	lpm	r26, Z+
 66c:	b4 91       	lpm	r27, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:42
  out = portOutputRegister(port);
 66e:	fc 01       	movw	r30, r24
 670:	ec 5c       	subi	r30, 0xCC	; 204
 672:	ff 4f       	sbci	r31, 0xFF	; 255
 674:	85 91       	lpm	r24, Z+
 676:	94 91       	lpm	r25, Z
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 678:	8f b7       	in	r24, 0x3f	; 63
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:58
                cli();
 67a:	f8 94       	cli
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 67c:	ec 91       	ld	r30, X
 67e:	e2 2b       	or	r30, r18
 680:	ec 93       	st	X, r30
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 682:	8f bf       	out	0x3f, r24	; 63
setup_watchdog():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:91
  //wake on Pin Change
}

//Sets the watchdog timer to wake us up, but not reset
void setup_watchdog() {
  cli();
 684:	f8 94       	cli
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:92
  MCUSR = 0;
 686:	14 be       	out	0x34, r1	; 52
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:94
  // allow changes, disable reset
  WDTCSR = bit (WDCE) | bit (WDE);
 688:	88 e1       	ldi	r24, 0x18	; 24
 68a:	81 bd       	out	0x21, r24	; 33
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:96
  // set interrupt and reset mode and an interval
  WDTCSR = bit (WDE) | bit (WDIE) | bit (WDP2) | bit (WDP1);    // set WDIE, and 1 second delay
 68c:	8e e4       	ldi	r24, 0x4E	; 78
 68e:	81 bd       	out	0x21, r24	; 33
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:97
  sei();
 690:	78 94       	sei
Flush_TWI_Buffers():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:54
static volatile uint8_t TWI_TxHead;
static volatile uint8_t TWI_TxTail;

void Flush_TWI_Buffers(void)
{
  TWI_RxTail = 0;
 692:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <TWI_RxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:55
  TWI_RxHead = 0;
 696:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <TWI_RxHead>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:56
  TWI_TxTail = 0;
 69a:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <TWI_TxTail>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:57
  TWI_TxHead = 0;
 69e:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <TWI_TxHead>
USI_TWI_Slave_Initialise():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:69
----------------------------------------------------------*/
void USI_TWI_Slave_Initialise(unsigned char TWI_ownAddress)
{
  Flush_TWI_Buffers();

  TWI_slaveAddress = TWI_ownAddress;
 6a2:	87 e0       	ldi	r24, 0x07	; 7
 6a4:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <TWI_slaveAddress>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:71

  USI_TWI_On_Slave_Transmit = 0;
 6a8:	10 92 8e 00 	sts	0x008E, r1	; 0x80008e <USI_TWI_On_Slave_Transmit+0x1>
 6ac:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <USI_TWI_On_Slave_Transmit>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:72
  USI_TWI_On_Slave_Receive = 0;
 6b0:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <USI_TWI_On_Slave_Receive+0x1>
 6b4:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <USI_TWI_On_Slave_Receive>
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:74

  PORT_USI_CL |= (1 << PORT_USI_SCL);     // Set SCL high
 6b8:	dc 9a       	sbi	0x1b, 4	; 27
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:75
  PORT_USI |= (1 << PORT_USI_SDA);        // Set SDA high
 6ba:	de 9a       	sbi	0x1b, 6	; 27
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:76
  DDR_USI_CL |= (1 << PORT_USI_SCL);      // Set SCL as output
 6bc:	d4 9a       	sbi	0x1a, 4	; 26
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:77
  DDR_USI &= ~(1 << PORT_USI_SDA);        // Set SDA as input
 6be:	d6 98       	cbi	0x1a, 6	; 26
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:78
  USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 6c0:	88 ea       	ldi	r24, 0xA8	; 168
 6c2:	8d b9       	out	0x0d, r24	; 13
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:83
          (1 << USIWM1) | (0 << USIWM0) | // Set USI in Two-wire mode. No USI Counter overflow prior
                                          // to first Start Condition (potential failure)
          (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
          (0 << USITC);
  USISR = 0xF0; // Clear all flags and reset overflow counter
 6c4:	80 ef       	ldi	r24, 0xF0	; 240
 6c6:	8e b9       	out	0x0e, r24	; 14
setup():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:37
void setup() {
  ADCSRA = 0; //Disable ADC, saves ~300uA
  pinMode(BoronENpin, OUTPUT);
  setup_watchdog(); //Setup watchdog to go off after 1sec
  Wire.begin(I2CADDR);
  PCMSK0 |= bit (PCINT2); //enable PC interupt on PA2
 6c8:	92 9a       	sbi	0x12, 2	; 18
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:38
  GIMSK |= bit (PCIE0); //enable PC interupts on bank 0
 6ca:	8b b7       	in	r24, 0x3b	; 59
 6cc:	80 61       	ori	r24, 0x10	; 16
 6ce:	8b bf       	out	0x3b, r24	; 59
onReceive():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:591
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 6d0:	c4 e0       	ldi	r28, 0x04	; 4
 6d2:	d1 e0       	ldi	r29, 0x01	; 1
onRequest():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:596
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 6d4:	0f e4       	ldi	r16, 0x4F	; 79
 6d6:	11 e0       	ldi	r17, 0x01	; 1
loop():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:42
}

void loop() {
  WDTCSR |= bit (WDIE); //kick the dog
 6d8:	81 b5       	in	r24, 0x21	; 33
 6da:	80 64       	ori	r24, 0x40	; 64
 6dc:	81 bd       	out	0x21, r24	; 33
onReceive():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:591
  // XXX: to be implemented.
}

// sets function called on slave write
void TwoWire::onReceive( void (*function)(int) ) {
  USI_TWI_On_Slave_Receive = function;
 6de:	d0 93 8c 00 	sts	0x008C, r29	; 0x80008c <USI_TWI_On_Slave_Receive+0x1>
 6e2:	c0 93 8b 00 	sts	0x008B, r28	; 0x80008b <USI_TWI_On_Slave_Receive>
onRequest():
C:\Users\jwiebe\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.2\libraries\Wire\src/Wire.cpp:596
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) ) {
  USI_TWI_On_Slave_Transmit = function;
 6e6:	10 93 8e 00 	sts	0x008E, r17	; 0x80008e <USI_TWI_On_Slave_Transmit+0x1>
 6ea:	00 93 8d 00 	sts	0x008D, r16	; 0x80008d <USI_TWI_On_Slave_Transmit>
loop():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:49
  //compute I2C
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);

  //Should I be waking the Particle master?
  if (((UNIXTime >= WakeTime) || digitalRead(BoronRQPin)) && digitalRead(VBAT_OKpin)) {
 6ee:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <UNIXTime>
 6f2:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <UNIXTime+0x1>
 6f6:	60 91 66 00 	lds	r22, 0x0066	; 0x800066 <UNIXTime+0x2>
 6fa:	70 91 67 00 	lds	r23, 0x0067	; 0x800067 <UNIXTime+0x3>
 6fe:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 702:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 706:	a0 91 62 00 	lds	r26, 0x0062	; 0x800062 <__data_start+0x2>
 70a:	b0 91 63 00 	lds	r27, 0x0063	; 0x800063 <__data_start+0x3>
 70e:	48 17       	cp	r20, r24
 710:	59 07       	cpc	r21, r25
 712:	6a 07       	cpc	r22, r26
 714:	7b 07       	cpc	r23, r27
 716:	b0 f0       	brcs	.+44     	; 0x744 <main+0x146>
 718:	83 e0       	ldi	r24, 0x03	; 3
 71a:	1b dd       	rcall	.-1482   	; 0x152 <digitalRead>
 71c:	89 2b       	or	r24, r25
 71e:	b1 f0       	breq	.+44     	; 0x74c <main+0x14e>
boronToggle():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:109
    //turn off
  digitalWrite(BoronENpin, LOW);
    boronControlState = 0;
  } else if (boronControlState == 0 && newState == 0) {
    //do nothing
  } else if (boronControlState == 0 && newState == 1) {
 720:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <boronControlState>
 724:	81 11       	cpse	r24, r1
 726:	06 c0       	rjmp	.+12     	; 0x734 <main+0x136>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:110
    digitalWrite(BoronENpin, HIGH);
 728:	61 e0       	ldi	r22, 0x01	; 1
 72a:	81 e0       	ldi	r24, 0x01	; 1
 72c:	3c dd       	rcall	.-1416   	; 0x1a6 <digitalWrite>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:111
    boronControlState = 1;
 72e:	81 e0       	ldi	r24, 0x01	; 1
 730:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <boronControlState>
idle():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:75
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); //Power down everything, wake up from WDT
  sleep_cpu();
}

void idle(){
  sleep_enable();
 734:	85 b7       	in	r24, 0x35	; 53
 736:	80 62       	ori	r24, 0x20	; 32
 738:	85 bf       	out	0x35, r24	; 53
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:76
  set_sleep_mode(SLEEP_MODE_IDLE);
 73a:	85 b7       	in	r24, 0x35	; 53
 73c:	87 7e       	andi	r24, 0xE7	; 231
sleep():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:70
  }
}

void sleep() {
  sleep_enable();
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); //Power down everything, wake up from WDT
 73e:	85 bf       	out	0x35, r24	; 53
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:71
  sleep_cpu();
 740:	88 95       	sleep
 742:	ca cf       	rjmp	.-108    	; 0x6d8 <main+0xda>
loop():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:49
  //compute I2C
  Wire.onReceive(receiveEvent);
  Wire.onRequest(requestEvent);

  //Should I be waking the Particle master?
  if (((UNIXTime >= WakeTime) || digitalRead(BoronRQPin)) && digitalRead(VBAT_OKpin)) {
 744:	82 e0       	ldi	r24, 0x02	; 2
 746:	05 dd       	rcall	.-1526   	; 0x152 <digitalRead>
 748:	89 2b       	or	r24, r25
 74a:	31 f7       	brne	.-52     	; 0x718 <main+0x11a>
boronToggle():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:103
}

void boronToggle(boolean newState) {
  if (boronControlState == 1 && newState == 1) {
    //do nothing
  } else if (boronControlState == 1 && newState == 0) {
 74c:	80 91 8f 00 	lds	r24, 0x008F	; 0x80008f <boronControlState>
 750:	81 30       	cpi	r24, 0x01	; 1
 752:	21 f4       	brne	.+8      	; 0x75c <main+0x15e>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:105
    //turn off
  digitalWrite(BoronENpin, LOW);
 754:	60 e0       	ldi	r22, 0x00	; 0
 756:	27 dd       	rcall	.-1458   	; 0x1a6 <digitalWrite>
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:106
    boronControlState = 0;
 758:	10 92 8f 00 	sts	0x008F, r1	; 0x80008f <boronControlState>
sleep():
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:69
    pinMode(LEDpin, INPUT);
  }
}

void sleep() {
  sleep_enable();
 75c:	85 b7       	in	r24, 0x35	; 53
 75e:	80 62       	ori	r24, 0x20	; 32
 760:	85 bf       	out	0x35, r24	; 53
S:\Research and Development\Tracking Collar\Luminous C\Software\ATTINYSupervisor/ATTINYSupervisor.ino:70
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); //Power down everything, wake up from WDT
 762:	85 b7       	in	r24, 0x35	; 53
 764:	87 7e       	andi	r24, 0xE7	; 231
 766:	80 61       	ori	r24, 0x10	; 16
 768:	ea cf       	rjmp	.-44     	; 0x73e <main+0x140>

0000076a <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 76a:	f8 94       	cli

0000076c <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 76c:	ff cf       	rjmp	.-2      	; 0x76c <__stop_program>
